!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports,require("@tensorflow/tfjs-core")):"function"==typeof define&&define.amd?define(["exports","@tensorflow/tfjs-core"],n):n(t.tsne={},t.tf)}(this,function(t,n){"use strict";function e(t,e,i){var r=n.webgl.webgl_util.createVertexShader(t,e),o=n.webgl.webgl_util.createFragmentShader(t,i),a=n.webgl.webgl_util.createProgram(t);return n.webgl.webgl_util.callAndCheck(t,function(){return t.attachShader(a,r)}),n.webgl.webgl_util.callAndCheck(t,function(){return t.attachShader(a,o)}),n.webgl.webgl_util.linkProgram(t,a),n.webgl.webgl_util.validateProgram(t,a),a}function i(t,e,i,r,l){n.webgl.webgl_util.validateTextureSize(t,e,i);var u=n.webgl.webgl_util.createTexture(t),g=t.TEXTURE_2D,h=o(t,r),p=a(t,r);return n.webgl.webgl_util.callAndCheck(t,function(){return t.bindTexture(g,u)}),n.webgl.webgl_util.callAndCheck(t,function(){return t.texParameteri(g,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)}),n.webgl.webgl_util.callAndCheck(t,function(){return t.texParameteri(g,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)}),n.webgl.webgl_util.callAndCheck(t,function(){return t.texParameteri(g,t.TEXTURE_MIN_FILTER,t.LINEAR)}),n.webgl.webgl_util.callAndCheck(t,function(){return t.texParameteri(g,t.TEXTURE_MAG_FILTER,t.LINEAR)}),n.webgl.webgl_util.callAndCheck(t,function(){return t.texImage2D(g,0,h,e,i,0,p,s(t),l)}),n.webgl.webgl_util.callAndCheck(t,function(){return t.bindTexture(t.TEXTURE_2D,null)}),u}function r(t,e,i,r,l){n.webgl.webgl_util.validateTextureSize(t,e,i);var u=n.webgl.webgl_util.createTexture(t),g=t.TEXTURE_2D,h=o(t,r),p=a(t,r);return n.webgl.webgl_util.callAndCheck(t,function(){return t.bindTexture(g,u)}),n.webgl.webgl_util.callAndCheck(t,function(){return t.texParameteri(g,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)}),n.webgl.webgl_util.callAndCheck(t,function(){return t.texParameteri(g,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)}),n.webgl.webgl_util.callAndCheck(t,function(){return t.texParameteri(g,t.TEXTURE_MIN_FILTER,t.NEAREST)}),n.webgl.webgl_util.callAndCheck(t,function(){return t.texParameteri(g,t.TEXTURE_MAG_FILTER,t.NEAREST)}),n.webgl.webgl_util.callAndCheck(t,function(){return t.texImage2D(g,0,h,e,i,0,p,s(t),l)}),n.webgl.webgl_util.callAndCheck(t,function(){return t.bindTexture(t.TEXTURE_2D,null)}),u}function o(t,n){return 4===n?t.RGBA32F:3===n?t.RGB32F:2===n?t.RG32F:t.R32F}function a(t,n){return 4===n?t.RGBA:3===n?t.RGB:2===n?t.RG:t.RED}function s(t){return t.FLOAT}function l(t){return"\n    #define DATA_NUM_PACKED_DIMENSIONS "+t.pixelsPerPoint+".\n    #define DATA_POINTS_PER_ROW "+t.pointsPerRow+".\n    #define DATA_NUM_ROWS "+t.numRows+".\n    #define TEXTURE_WIDTH "+t.pointsPerRow*t.pixelsPerPoint+".\n\n    //returns the texture coordinate for point/dimension\n    vec2 dataTexCoordinates(int id, int dimension) {\n      float id_f = float(id);\n      float row = (floor(id_f/DATA_POINTS_PER_ROW)+0.5) / DATA_NUM_ROWS;\n      float col = ((mod(id_f,DATA_POINTS_PER_ROW)*(DATA_NUM_PACKED_DIMENSIONS)\n                  + float(dimension)) + 0.5) / (TEXTURE_WIDTH);\n      return vec2(col,row);\n    }\n\n    //compute the euclidean squared distances between two points i and j\n    float pointDistanceSquared(int i, int j) {\n      vec4 result = vec4(0,0,0,0);\n      int num_iter = int(DATA_NUM_PACKED_DIMENSIONS);\n      for(int d = 0; d < num_iter; ++d) {\n        vec4 vi = texture(data_tex,dataTexCoordinates(i,d));\n        vec4 vj = texture(data_tex,dataTexCoordinates(j,d));\n        result += (vi-vj)*(vi-vj);\n      }\n      return (result.r+result.g+result.b+result.a);\n    }\n\n    //compute the euclidean squared distances between two points i and j\n    vec4 pointDistanceSquaredBatch(int i, int j0, int j1, int j2, int j3) {\n      vec4 result = vec4(0,0,0,0);\n      int num_iter = int(DATA_NUM_PACKED_DIMENSIONS);\n      for(int d = 0; d < num_iter; ++d) {\n        vec4 vi = texture(data_tex,dataTexCoordinates(i,d));\n        vec4 vj0 = texture(data_tex,dataTexCoordinates(j0,d));\n        vec4 vj1 = texture(data_tex,dataTexCoordinates(j1,d));\n        vec4 vj2 = texture(data_tex,dataTexCoordinates(j2,d));\n        vec4 vj3 = texture(data_tex,dataTexCoordinates(j3,d));\n        vj0 = (vi-vj0); vj0 *= vj0;\n        vj1 = (vi-vj1); vj1 *= vj1;\n        vj2 = (vi-vj2); vj2 *= vj2;\n        vj3 = (vi-vj3); vj3 *= vj3;\n        result.r += (vj0.r+vj0.g+vj0.b+vj0.a);\n        result.g += (vj1.r+vj1.g+vj1.b+vj1.a);\n        result.b += (vj2.r+vj2.g+vj2.b+vj2.a);\n        result.a += (vj3.r+vj3.g+vj3.b+vj3.a);\n      }\n      return result;\n    }\n    "}function u(t,n){return"#version 300 es\n    precision highp float;\n    uniform sampler2D data_tex;\n    uniform float num_points;\n    uniform float points_per_row_knn;\n    uniform float num_rows_knn;\n    uniform float num_neighs;\n    uniform float iteration;\n\n    #define NUM_PACKED_NEIGHBORS "+n/4+"\n\n    flat in vec4 knn[NUM_PACKED_NEIGHBORS];\n    flat in int point_id;\n    in float neighbor_id;\n\n    const float MAX_DIST = 10e30;\n\n    "+t+"\n\n    out vec4 fragmentColor;\n    void main() {\n      int id = int(neighbor_id/4.);\n      int channel = int(mod(neighbor_id,4.)+0.1);\n\n      if(channel == 0) {\n        fragmentColor = vec4(knn[id].r,0,0,1);\n      }else if(channel == 1) {\n        fragmentColor = vec4(knn[id].g,0,0,1);\n      }else if(channel == 2) {\n        fragmentColor = vec4(knn[id].b,0,0,1);\n      }else if(channel == 3) {\n        fragmentColor = vec4(knn[id].a,0,0,1);\n      }\n\n      //If the neighbor has a valid id i compute the distance squared\n      //otherwise I set it to invalid\n      if(fragmentColor.r >= 0.) {\n        fragmentColor.g = pointDistanceSquared(int(fragmentColor.r),point_id);\n      }else{\n        fragmentColor.g = MAX_DIST;\n      }\n    }\n  "}function g(t){return"\n  precision highp float;\n  #define NEIGH_PER_ITER 20\n  #define NUM_NEIGHBORS "+t+"\n  #define NUM_NEIGHBORS_FLOAT "+t+".\n  #define NUM_PACKED_NEIGHBORS "+t/4+"\n  #define MAX_DIST 10e30\n\n  //attributes\n  in float vertex_id;\n  //uniforms\n  uniform sampler2D data_tex;\n  uniform sampler2D starting_knn_tex;\n  uniform float num_points;\n  uniform float points_per_row_knn;\n  uniform float num_rows_knn;\n  uniform float num_neighs;\n  uniform float iteration;\n\n  //output\n  //the indices are packed in varying vectors\n  flat out vec4 knn[NUM_PACKED_NEIGHBORS];\n  //used to recover the neighbor id in the fragment shader\n  out float neighbor_id;\n  //used to recover the point id in the fragment shader\n  //(for recomputing distances)\n  flat out int point_id;\n\n  float distances_heap[NUM_NEIGHBORS];\n  int knn_heap[NUM_NEIGHBORS];\n  "}function h(t,n,i){var r="#version 300 es\n    "+g(n)+G+i+z+"\n    void main() {\n      //Getting the id of the point and the line id (0/1)\n      point_id = int((vertex_id / 2.0) + 0.1);\n      int line_id = int(mod(vertex_id + 0.1, 2.));\n      if(float(point_id) >= num_points) {\n        return;\n      }\n\n      "+B+"\n\n      //////////////////////////////////\n      //KNN computation\n      initializeDistances(point_id);\n      for(int i = 0; i < NEIGH_PER_ITER; i += 4) {\n        //TODO make it more readable\n\n        int j = int(mod(\n                    float(point_id + i) //point id + current offset\n                    + iteration * float(NEIGH_PER_ITER) //iteration offset\n                    + 1.25,// +1 for avoid checking the point itself,\n                           // +0.25 for error compensation\n                    num_points\n                  ));\n        vec4 dist_squared = pointDistanceSquaredBatch(point_id,j,j+1,j+2,j+3);\n        insertInKNN(dist_squared.r, j);\n        insertInKNN(dist_squared.g, j+1);\n        insertInKNN(dist_squared.b, j+2);\n        insertInKNN(dist_squared.a, j+3);\n      }\n\n      for(int n = 0; n < NUM_PACKED_NEIGHBORS; n++) {\n        knn[n].r = float(knn_heap[n*4]);\n        knn[n].g = float(knn_heap[n*4+1]);\n        knn[n].b = float(knn_heap[n*4+2]);\n        knn[n].a = float(knn_heap[n*4+3]);\n      }\n\n      neighbor_id = NUM_NEIGHBORS_FLOAT;\n    }\n  ",o=u(i,n);return e(t.gl,r,o)}function p(t,n,i){var r="#version 300 es\n    "+g(n)+G+L+i+z+"\n    void main() {\n      //Getting the id of the point and the line id (0/1)\n      point_id = int((vertex_id/2.0)+0.1);\n      int line_id = int(mod(vertex_id+0.1,2.));\n      if(float(point_id) >= num_points) {\n        return;\n      }\n\n      "+B+"\n\n      //////////////////////////////////\n      //KNN computation\n\n      initializeDistances(point_id);\n      for(int i = 0; i < NEIGH_PER_ITER; i += 4) {\n        //BAD SEED\n        //uint seed\n        //= uint(float(point_id) + float(NEIGH_PER_ITER)*iteration + float(i));\n        //GOOD SEED\n        //uint seed\n        //= uint(float(point_id) + float(num_points)*iteration + float(i));\n\n        float seed\n            = float(float(point_id) + float(num_points)*iteration + float(i));\n        int j0 = int(random(seed)*num_points);\n        int j1 = int(random(seed+1.)*num_points);\n        int j2 = int(random(seed+2.)*num_points);\n        int j3 = int(random(seed+3.)*num_points);\n\n        vec4 dist_squared = pointDistanceSquaredBatch(point_id,j0,j1,j2,j3);\n        if(j0!=point_id)insertInKNN(dist_squared.r, j0);\n        if(j1!=point_id)insertInKNN(dist_squared.g, j1);\n        if(j2!=point_id)insertInKNN(dist_squared.b, j2);\n        if(j3!=point_id)insertInKNN(dist_squared.a, j3);\n      }\n\n      for(int n = 0; n < NUM_PACKED_NEIGHBORS; n++) {\n        knn[n].r = float(knn_heap[n*4]);\n        knn[n].g = float(knn_heap[n*4+1]);\n        knn[n].b = float(knn_heap[n*4+2]);\n        knn[n].a = float(knn_heap[n*4+3]);\n      }\n      neighbor_id = NUM_NEIGHBORS_FLOAT;\n    }\n  ",o=u(i,n);return e(t.gl,r,o)}function m(t,n,i){var r="#version 300 es\n    "+g(n)+G+L+i+z+"\n    int fetchNeighborIdFromKNNTexture(int id, int neighbor_id) {\n      //row coordinate in the texture\n      float row = (floor(float(id)/points_per_row_knn)+0.5)/num_rows_knn;\n      //column of the first neighbor\n      float start_col = mod(float(id),points_per_row_knn)*NUM_NEIGHBORS_FLOAT;\n      //column of the neighbor of interest\n      float col = (start_col+float(neighbor_id)+0.5);\n      //normalized by the width of the texture\n      col /= (points_per_row_knn*NUM_NEIGHBORS_FLOAT);\n      //reads the index in the red channel and the distances in the green one\n      vec4 knn_link = texture(starting_knn_tex,vec2(col,row));\n      //return the index\n      return int(knn_link.r);\n    }\n\n    int neighborOfANeighbor(int my_id, uint seed) {\n      //float random0 = hash1(seed);\n      float random0 = random(float(seed));\n      // random0 = random0*random0;\n      // random0 = 1. - random0;\n\n      //float random1 = hash1(seed*1798191U);\n      float random1 = random(float(seed+7U));\n      // random1 = random1*random1;\n      // random1 = 1. - random1;\n\n      //fetch a neighbor from the heap\n      int neighbor = knn_heap[int(random0*NUM_NEIGHBORS_FLOAT)];\n      //if it is not a valid pick a random point\n      if(neighbor < 0) {\n        return int(random(float(seed))*num_points);\n      }\n\n      //if it is valid I fetch from the knn graph texture one of its neighbors\n      int neighbor2ndDegree = fetchNeighborIdFromKNNTexture(\n                                    neighbor,int(random1*NUM_NEIGHBORS_FLOAT));\n      //if it is not a valid pick a random point\n      if(neighbor2ndDegree < 0) {\n        return int(random(float(seed))*num_points);\n      }\n      return neighbor2ndDegree;\n    }\n\n    void main() {\n      //Getting the id of the point and the line id (0/1)\n      point_id = int((vertex_id/2.0)+0.1);\n      int line_id = int(mod(vertex_id+0.1,2.));\n      if(float(point_id) >= num_points) {\n        return;\n      }\n      "+B+"\n\n      //////////////////////////////////\n      //KNN computation\n      initializeDistances(point_id);\n      for(int i = 0; i < NEIGH_PER_ITER; i += 4) {\n        //BAD SEED\n        //uint seed\n        //= uint(float(point_id) + float(NEIGH_PER_ITER)*iteration + float(i));\n        //GOOD SEED\n        uint seed\n              = uint(float(point_id) + float(num_points)*iteration + float(i));\n        int j0 = neighborOfANeighbor(point_id,seed);\n        int j1 = neighborOfANeighbor(point_id,seed+1U);\n        int j2 = neighborOfANeighbor(point_id,seed+2U);\n        int j3 = neighborOfANeighbor(point_id,seed+3U);\n\n        vec4 dist_squared = pointDistanceSquaredBatch(point_id,j0,j1,j2,j3);\n        if(j0!=point_id)insertInKNN(dist_squared.r, j0);\n        if(j1!=point_id)insertInKNN(dist_squared.g, j1);\n        if(j2!=point_id)insertInKNN(dist_squared.b, j2);\n        if(j3!=point_id)insertInKNN(dist_squared.a, j3);\n      }\n\n      for(int n = 0; n < NUM_PACKED_NEIGHBORS; n++) {\n        knn[n].r = float(knn_heap[n*4]);\n        knn[n].g = float(knn_heap[n*4+1]);\n        knn[n].b = float(knn_heap[n*4+2]);\n        knn[n].a = float(knn_heap[n*4+3]);\n      }\n      neighbor_id = NUM_NEIGHBORS_FLOAT;\n    }\n  ",o=u(i,n);return e(t.gl,r,o)}function _(t,e,i,r,o,a,s,l){var u=t.gl,g=t.program,h=u.getParameter(u.LINE_WIDTH);null!=l?t.setOutputMatrixTexture(l,a.numRows,a.pointsPerRow*a.pixelsPerPoint):n.webgl.webgl_util.bindCanvasToFramebuffer(t.gl),1!==h&&u.lineWidth(1),t.setProgram(e),u.clearColor(0,0,0,0),u.clear(u.COLOR_BUFFER_BIT),n.webgl.webgl_util.callAndCheck(u,function(){return u.bindBuffer(u.ARRAY_BUFFER,s)}),n.webgl.webgl_util.bindVertexBufferToProgramAttribute(u,e,"vertex_id",s,1,0,0);var p=n.webgl.webgl_util.getProgramUniformLocationOrThrow(u,e,"data_tex");t.setInputMatrixTexture(i,p,0);var m=n.webgl.webgl_util.getProgramUniformLocationOrThrow(u,e,"starting_knn_tex");t.setInputMatrixTexture(r,m,1);var _=n.webgl.webgl_util.getProgramUniformLocationOrThrow(u,e,"iteration");u.uniform1f(_,o);var f=n.webgl.webgl_util.getProgramUniformLocationOrThrow(u,e,"num_points");u.uniform1f(f,a.numPoints);var d=n.webgl.webgl_util.getProgramUniformLocationOrThrow(u,e,"points_per_row_knn");u.uniform1f(d,a.pointsPerRow);var c=n.webgl.webgl_util.getProgramUniformLocationOrThrow(u,e,"num_rows_knn");u.uniform1f(c,a.numRows),n.webgl.webgl_util.callAndCheck(u,function(){return u.drawArrays(u.LINES,0,2*a.numPoints)}),null!=g&&(t.setProgram(g),n.webgl.gpgpu_util.bindVertexProgramAttributeStreams(t.gl,g,t.vertexBuffer)),1!==h&&u.lineWidth(h)}function f(t){return t.createProgram("\n    precision highp float;\n    uniform sampler2D knn_tex;\n    uniform float width;\n    uniform float height;\n\n    void main() {\n      vec2 coordinates = gl_FragCoord.xy / vec2(width,height);\n      float distance = texture2D(knn_tex,coordinates).g;\n      gl_FragColor = vec4(distance,0,0,1);\n    }\n  ")}function d(t,e,i,r,o){var a=t.gl;null!=o?t.setOutputMatrixTexture(o,r.numRows,r.pointsPerRow*r.pixelsPerPoint):n.webgl.webgl_util.bindCanvasToFramebuffer(t.gl),t.setProgram(e);var s=n.webgl.webgl_util.getProgramUniformLocationOrThrow(a,e,"knn_tex");t.setInputMatrixTexture(i,s,0);var l=n.webgl.webgl_util.getProgramUniformLocationOrThrow(a,e,"width");a.uniform1f(l,r.pointsPerRow*r.pixelsPerPoint);var u=n.webgl.webgl_util.getProgramUniformLocationOrThrow(a,e,"height");a.uniform1f(u,r.numRows),t.executeProgram()}function c(t){return t.createProgram("\n    precision highp float;\n    uniform sampler2D knn_tex;\n    uniform float width;\n    uniform float height;\n\n    void main() {\n      vec2 coordinates = gl_FragCoord.xy / vec2(width,height);\n      float id = texture2D(knn_tex,coordinates).r;\n      gl_FragColor = vec4(id,0,0,1);\n\n      if(id < 0.) {\n        gl_FragColor.b = 1.;\n      }\n    }\n  ")}function b(t,e,i,r,o){var a=t.gl;null!=o?t.setOutputMatrixTexture(o,r.numRows,r.pointsPerRow*r.pixelsPerPoint):n.webgl.webgl_util.bindCanvasToFramebuffer(t.gl),t.setProgram(e);var s=n.webgl.webgl_util.getProgramUniformLocationOrThrow(a,e,"knn_tex");t.setInputMatrixTexture(i,s,0);var l=n.webgl.webgl_util.getProgramUniformLocationOrThrow(a,e,"width");a.uniform1f(l,r.pointsPerRow*r.pixelsPerPoint);var u=n.webgl.webgl_util.getProgramUniformLocationOrThrow(a,e,"height");a.uniform1f(u,r.numRows),t.executeProgram()}function w(t){return"numPoints"in t&&"pointsPerRow"in t&&"pixelsPerPoint"in t&&"numRows"in t}function x(t){return"distanceComputationCode"in t}function v(t,n,e,i){return new(e||(e=Promise))(function(r,o){function a(t){try{l(i.next(t))}catch(t){o(t)}}function s(t){try{l(i.throw(t))}catch(t){o(t)}}function l(t){t.done?r(t.value):new e(function(n){n(t.value)}).then(a,s)}l((i=i.apply(t,n||[])).next())})}function P(t,n){function e(t){return function(n){return i([t,n])}}function i(e){if(r)throw new TypeError("Generator is already executing.");for(;l;)try{if(r=1,o&&(a=2&e[0]?o.return:e[0]?o.throw||((a=o.return)&&a.call(o),0):o.next)&&!(a=a.call(o,e[1])).done)return a;switch(o=0,a&&(e=[2&e[0],a.value]),e[0]){case 0:case 1:a=e;break;case 4:return l.label++,{value:e[1],done:!1};case 5:l.label++,o=e[1],e=[0];continue;case 7:e=l.ops.pop(),l.trys.pop();continue;default:if(a=l.trys,!(a=a.length>0&&a[a.length-1])&&(6===e[0]||2===e[0])){l=0;continue}if(3===e[0]&&(!a||e[1]>a[0]&&e[1]<a[3])){l.label=e[1];break}if(6===e[0]&&l.label<a[1]){l.label=a[1],a=e;break}if(a&&l.label<a[2]){l.label=a[2],l.ops.push(e);break}a[2]&&l.ops.pop(),l.trys.pop();continue}e=n.call(t,l)}catch(t){e=[6,t],o=0}finally{r=a=0}if(5&e[0])throw e[1];return{value:e[0]?e[1]:void 0,done:!0}}var r,o,a,s,l={label:0,sent:function(){if(1&a[0])throw a[1];return a[1]},trys:[],ops:[]};return s={next:e(0),throw:e(1),return:e(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s}function T(t){return v(this,void 0,void 0,function(){var e,i,o,a,s,l,u,g,h,p,m,_,f,d,c,b,w;return P(this,function(x){if(2!==(e=t.shape).length)throw Error("tensorToDataTexture: input tensor must be 2-dimensional");if(null===(i=n.ENV.findBackend("webgl")))throw Error("WebGL backend is not available");for(o=i.getGPGPUContext(),a=e[0],s=e[1],l=4,u=Math.ceil(s/l),g=Math.floor(Math.sqrt(a*u)/u),h=Math.ceil(a/g),p=t.dataSync(),m=new Float32Array(g*u*h*l),_=0;_<a;++_)for(f=_*s,d=_*u*l,c=0;c<s;++c)m[d+c]=p[f+c];return b=r(o.gl,g*u,h,4,m),w={numPoints:a,pointsPerRow:g,numRows:h,pixelsPerPoint:u},[2,{shape:w,texture:b}]})})}function k(t){return e(t.gl,"#version 300 es\n    precision highp float;\n    in float vertex_id;\n\n    uniform sampler2D embedding_tex;\n    uniform vec2 minV;\n    uniform vec2 maxV;\n    uniform float kernel_support;\n    uniform float points_per_row;\n    uniform float num_rows;\n\n    out vec2 kernel_coords;\n\n    void main() {\n      //TODO Clean up and check performance loss due to the conversions\n      uint pnt_id = uint((vertex_id / 4.0) + 0.1);\n      uint quad_id = uint(mod(vertex_id + 0.1,4.));\n\n      uint row    = uint((float(pnt_id) + 0.1)/points_per_row);\n      uint column = uint(float(pnt_id) - float(row) * points_per_row);\n\n      float width = (points_per_row * 2.0);\n      float row_tex = (float(row) + 0.5) / num_rows;\n      vec2 tex_coords_x = vec2((float(column) * 2. + 0.5) / width, row_tex);\n      vec2 tex_coords_y = vec2((float(column) * 2. + 1.5) / width, row_tex);\n\n      float x_pnt = texture(embedding_tex,tex_coords_x).r;\n      float y_pnt = texture(embedding_tex,tex_coords_y).r;\n      vec2 vertex_coords = vec2(x_pnt,y_pnt);\n\n      if(quad_id == uint(0)) {kernel_coords = vec2(-1,-1);}\n      else if(quad_id == uint(1)) {kernel_coords = vec2(1,-1);}\n      else if(quad_id == uint(2)) {kernel_coords = vec2(1,1);}\n      else if(quad_id == uint(3)) {kernel_coords = vec2(-1,1);}\n\n      vertex_coords += kernel_coords * kernel_support;      // embedding space\n      vertex_coords = (vertex_coords - minV) / (maxV-minV); //  0:1 space\n      vertex_coords = vertex_coords * 2.0 - 1.0;            // -1:1 space\n\n      gl_Position = vec4(vertex_coords,0,1);\n    }\n  ","#version 300 es\n    precision highp float;\n    uniform sampler2D kernel_tex;\n    in vec2 kernel_coords;\n    out vec4 fragmentColor;\n\n    void main() {\n      fragmentColor = texture(kernel_tex,(kernel_coords + 1.) / 2.0);\n    }\n  ")}function N(t,e,i,r,o,a,s,l,u,g,h,p,m,_,f){var d=t.gl,c=t.program;null!=i?t.setOutputMatrixTexture(i,a,a):n.webgl.webgl_util.bindCanvasToFramebuffer(t.gl),t.setProgram(e),d.clearColor(0,0,0,0),d.clear(d.COLOR_BUFFER_BIT),d.enable(d.BLEND),d.blendFunc(d.ONE,d.ONE),n.webgl.webgl_util.callAndCheck(d,function(){return d.bindBuffer(d.ARRAY_BUFFER,f)}),n.webgl.webgl_util.bindVertexBufferToProgramAttribute(d,e,"vertex_id",f,1,0,0);var b=n.webgl.webgl_util.getProgramUniformLocationOrThrow(d,e,"embedding_tex");t.setInputMatrixTexture(r,b,0);var w=n.webgl.webgl_util.getProgramUniformLocationOrThrow(d,e,"kernel_tex");t.setInputMatrixTexture(o,w,1);var x=n.webgl.webgl_util.getProgramUniformLocationOrThrow(d,e,"kernel_support");d.uniform1f(x,p);var v=n.webgl.webgl_util.getProgramUniformLocationOrThrow(d,e,"points_per_row");d.uniform1f(v,m);var P=n.webgl.webgl_util.getProgramUniformLocationOrThrow(d,e,"num_rows");d.uniform1f(P,_);var T=n.webgl.webgl_util.getProgramUniformLocationOrThrow(d,e,"minV");d.uniform2f(T,l,u);var k=n.webgl.webgl_util.getProgramUniformLocationOrThrow(d,e,"maxV");d.uniform2f(k,g,h),n.webgl.webgl_util.callAndCheck(d,function(){return d.drawArrays(d.TRIANGLES,0,2*s*3)}),d.disable(d.BLEND),null!=c&&(t.setProgram(c),n.webgl.gpgpu_util.bindVertexProgramAttributeStreams(t.gl,c,t.vertexBuffer))}function y(t){return t.createProgram("\n    precision highp float;\n    uniform sampler2D embedding_tex;\n    uniform sampler2D splat_tex;\n    uniform vec2 minV;\n    uniform vec2 maxV;\n    uniform float points_per_row;\n    uniform float num_rows;\n    uniform float num_points;\n\n    void main() {\n      vec2 pnt_location = gl_FragCoord.xy - vec2(0.5,0.5);\n\n      if(pnt_location.y * points_per_row + pnt_location.x >= num_points) {\n        gl_FragColor = vec4(0,0,0,0);\n        return;\n      }\n\n      float emb_width = (points_per_row * 2.0);\n      float emb_row_coord = (pnt_location.y + 0.5) / num_rows;\n      vec2 emb_coords_x\n              = vec2((pnt_location.x * 2.+0.5) / emb_width, emb_row_coord);\n      vec2 emb_coords_y\n              = vec2((pnt_location.x * 2. + 1.5) / emb_width, emb_row_coord);\n\n      float x_pnt = texture2D(embedding_tex,emb_coords_x).r;\n      float y_pnt = texture2D(embedding_tex,emb_coords_y).r;\n\n      vec2 splat_coords = vec2(x_pnt,y_pnt);\n      splat_coords = (splat_coords - minV) / (maxV - minV); //  0:1 space\n\n      float q = (texture2D(splat_tex,splat_coords).r - 1.);\n\n      gl_FragColor = vec4(q, 0, 0, 1);\n    }\n  ")}function R(t,e,i,r,o,a,s,l,u,g,h,p){var m=t.gl;null!=p?t.setOutputMatrixTexture(p,h,g):n.webgl.webgl_util.bindCanvasToFramebuffer(t.gl),t.setProgram(e);var _=n.webgl.webgl_util.getProgramUniformLocationOrThrow(m,e,"embedding_tex");t.setInputMatrixTexture(r,_,0);var f=n.webgl.webgl_util.getProgramUniformLocationOrThrow(m,e,"splat_tex");t.setInputMatrixTexture(i,f,1);var d=n.webgl.webgl_util.getProgramUniformLocationOrThrow(m,e,"points_per_row");m.uniform1f(d,g);var c=n.webgl.webgl_util.getProgramUniformLocationOrThrow(m,e,"num_rows");m.uniform1f(c,h);var b=n.webgl.webgl_util.getProgramUniformLocationOrThrow(m,e,"num_points");m.uniform1f(b,o);var w=n.webgl.webgl_util.getProgramUniformLocationOrThrow(m,e,"minV");m.uniform2f(w,a,s);var x=n.webgl.webgl_util.getProgramUniformLocationOrThrow(m,e,"maxV");m.uniform2f(x,l,u),t.executeProgram()}function E(t){return t.createProgram("\n    precision highp float;\n    uniform sampler2D embedding_tex;\n    uniform sampler2D splat_tex;\n    uniform vec2 minV;\n    uniform vec2 maxV;\n    uniform float points_per_row;\n    uniform float num_rows;\n    uniform float num_points;\n    uniform float eta;\n\n    void main() {\n      vec2 pnt_location = gl_FragCoord.xy - vec2(0.5,0.5);\n      pnt_location.x = floor(pnt_location.x/2.+0.1);\n\n      if(pnt_location.y*points_per_row + pnt_location.x >= num_points) {\n        gl_FragColor = vec4(0,0,0,0);\n        return;\n      }\n\n      float emb_width = (points_per_row * 2.0);\n      float emb_row_coord = (pnt_location.y + 0.5) / num_rows;\n      vec2 emb_coords_x\n              = vec2((pnt_location.x * 2. + 0.5) / emb_width, emb_row_coord);\n      vec2 emb_coords_y\n              = vec2((pnt_location.x * 2. + 1.5) / emb_width, emb_row_coord);\n\n      float x_pnt = texture2D(embedding_tex,emb_coords_x).r;\n      float y_pnt = texture2D(embedding_tex,emb_coords_y).r;\n\n      vec2 splat_coords = vec2(x_pnt,y_pnt);\n      splat_coords = (splat_coords - minV) / (maxV - minV); //  0:1 space\n\n      float q = 0.;\n      if(mod(gl_FragCoord.x - 0.5,2.) < 0.5 ) {\n        q = texture2D(splat_tex,splat_coords).g * eta * 2.;\n      }else{\n        q = texture2D(splat_tex,splat_coords).b * eta * 2.;\n      }\n\n      gl_FragColor = vec4(q,0.0,0.0,1);\n    }\n  ")}function D(t,e,i,r,o,a,s,l,u,g,h,p,m){var _=t.gl;null!=o?t.setOutputMatrixTexture(o,p,2*h):n.webgl.webgl_util.bindCanvasToFramebuffer(t.gl),t.setProgram(e);var f=n.webgl.webgl_util.getProgramUniformLocationOrThrow(_,e,"embedding_tex");t.setInputMatrixTexture(r,f,0);var d=n.webgl.webgl_util.getProgramUniformLocationOrThrow(_,e,"splat_tex");t.setInputMatrixTexture(i,d,1);var c=n.webgl.webgl_util.getProgramUniformLocationOrThrow(_,e,"points_per_row");_.uniform1f(c,h);var b=n.webgl.webgl_util.getProgramUniformLocationOrThrow(_,e,"num_rows");_.uniform1f(b,p);var w=n.webgl.webgl_util.getProgramUniformLocationOrThrow(_,e,"num_points");_.uniform1f(w,a);var x=n.webgl.webgl_util.getProgramUniformLocationOrThrow(_,e,"eta");_.uniform1f(x,m);var v=n.webgl.webgl_util.getProgramUniformLocationOrThrow(_,e,"minV");_.uniform2f(v,s,l);var P=n.webgl.webgl_util.getProgramUniformLocationOrThrow(_,e,"maxV");_.uniform2f(P,u,g),t.executeProgram()}function O(t){return t.createProgram("\n    precision highp float;\n\n    uniform sampler2D embedding_tex;\n    uniform sampler2D offset_tex;\n    uniform sampler2D neigh_id_tex;\n    uniform sampler2D neigh_prob_tex;\n\n    uniform float points_per_row;\n    uniform float num_rows;\n    uniform float num_points;\n    uniform float num_neighs_per_row;\n    uniform float eta;\n\n    void main() {\n      //add for nearest pixel interpolation\n      vec2 half_pxl = vec2(0.5,0.5);\n\n      // Dimension of the fragment\n      // 0 -> x :1 -> y\n      float dimension = mod(gl_FragCoord.x - 0.4,2.);\n\n      //Point location in the [points_per_row,num_rows] space\n      vec2 i_location = gl_FragCoord.xy - half_pxl;\n      i_location.x = floor(i_location.x / 2. + 0.1);\n\n      //just an extra fragment -> return\n      if(i_location.y*points_per_row + i_location.x >= num_points) {\n        gl_FragColor = vec4(0,0,0,0);\n        return;\n      }\n\n      //Offset coordinates for the point\n      vec2 offset_coord = (i_location + half_pxl) /\n                                              vec2(points_per_row,num_rows);\n      //Offset information ...\n      vec4 offset_info  = texture2D(offset_tex,offset_coord);\n      //... contains the number of neighbors for the point ...\n      float num_neighs  = offset_info.z;\n      //... and the coordinates of the firts neigh in the neigh textures\n      vec2 offset_neigh = offset_info.xy;\n\n      //Computing the coordinates of the point in the texture\n      //_i represent the point to move, _j the neighbors\n      float emb_width = (points_per_row * 2.0);\n      float emb_row_i = (i_location.y + 0.5) / num_rows;\n      vec2 x_i_coord = vec2((i_location.x * 2. + 0.5) / emb_width, emb_row_i);\n      vec2 y_i_coord = vec2((i_location.x * 2. + 1.5) / emb_width, emb_row_i);\n      //getting the coordinates in the embedding\n      float x_i = texture2D(embedding_tex,x_i_coord).r;\n      float y_i = texture2D(embedding_tex,y_i_coord).r;\n\n      //Sum of all attractive forces\n      float sum_pos = 0.;\n\n      //Can't be higher than 1000 (perplexity is usually around 30)\n      //and a 'while' can't be used\n      for(int n = 0; n < 2000; ++n) {\n        //Actual check on number of neighbors\n        if(float(n) >= num_neighs) {\n          break;\n        }\n\n        //Get the id and the probability for the neighbor\n        float pij = texture2D(neigh_prob_tex,\n                              (offset_neigh + half_pxl) / num_neighs_per_row\n                             ).r;\n        float neigh_id = texture2D(neigh_id_tex,\n                                  (offset_neigh + half_pxl) / num_neighs_per_row\n                                  ).r;\n\n        //Getting the coordinates of the neighbor\n        vec2 j_location = vec2(mod(neigh_id + 0.1, points_per_row),\n                               floor(neigh_id / points_per_row + 0.1));\n        float emb_row_j = (j_location.y + 0.5) / num_rows;\n        vec2 x_j_coord = vec2((j_location.x * 2. + 0.5) / emb_width, emb_row_j);\n        vec2 y_j_coord = vec2((j_location.x * 2. + 1.5) / emb_width, emb_row_j);\n        float x_j = texture2D(embedding_tex,x_j_coord).r;\n        float y_j = texture2D(embedding_tex,y_j_coord).r;\n\n        //Actual computation of the attractive forces\n        float dist_x    = (x_i - x_j);\n        float dist_y    = (y_i - y_j);\n        float qij       = 1. / (1. + dist_x * dist_x + dist_y * dist_y);\n        //the update depends on the dimension that this fragment represents\n        if(dimension < 0.5) {\n          // * 4 / (num_points*2) -> * 2 / num_points\n          sum_pos += eta * 2. * pij * qij * dist_x / (num_points);\n        }else{\n          sum_pos += eta * 2. * pij * qij * dist_y / (num_points);\n        }\n\n        //Increase the coordinate of the neigh in the neigh_id texture\n        offset_neigh.x += 1.;\n        //check if the new neigh is in the next row\n        if(offset_neigh.x + 0.2 > num_neighs_per_row) {\n          //in that case reset the column and increase the row\n          offset_neigh.x = 0.1;\n          offset_neigh.y += 1.0;\n        }\n      }\n\n      //The output is the sum of the attractive forces\n      gl_FragColor = vec4(sum_pos,0,0,0);\n    }\n  ")}function I(t,e,i,r,o,a,s,l,u,g,h,p){var m=t.gl;null!=p?t.setOutputMatrixTexture(p,g,2*u):n.webgl.webgl_util.bindCanvasToFramebuffer(t.gl),t.setProgram(e);var _=n.webgl.webgl_util.getProgramUniformLocationOrThrow(m,e,"embedding_tex");t.setInputMatrixTexture(i,_,3);var f=n.webgl.webgl_util.getProgramUniformLocationOrThrow(m,e,"offset_tex");t.setInputMatrixTexture(r,f,2);var d=n.webgl.webgl_util.getProgramUniformLocationOrThrow(m,e,"neigh_id_tex");t.setInputMatrixTexture(o,d,1);var c=n.webgl.webgl_util.getProgramUniformLocationOrThrow(m,e,"neigh_prob_tex");t.setInputMatrixTexture(a,c,0);var b=n.webgl.webgl_util.getProgramUniformLocationOrThrow(m,e,"num_rows");m.uniform1f(b,g);var w=n.webgl.webgl_util.getProgramUniformLocationOrThrow(m,e,"eta");m.uniform1f(w,h);var x=n.webgl.webgl_util.getProgramUniformLocationOrThrow(m,e,"num_neighs_per_row");m.uniform1f(x,l);var v=n.webgl.webgl_util.getProgramUniformLocationOrThrow(m,e,"num_points");m.uniform1f(v,s);var P=n.webgl.webgl_util.getProgramUniformLocationOrThrow(m,e,"points_per_row");m.uniform1f(P,u),t.executeProgram()}function A(t){return t.createProgram("\n    precision highp float;\n\n    uniform sampler2D random_tex;\n    uniform float points_per_row;\n    uniform float num_rows;\n    uniform float num_points;\n\n    void main() {\n      //add for nearest pixel interpolation\n      vec2 half_pxl = vec2(0.5,0.5);\n\n      // Dimension of the fragment\n      // 0 -> x :1 -> y\n      float dimension = mod(gl_FragCoord.x - 0.4,2.);\n      vec2 pnt_location = gl_FragCoord.xy - half_pxl;\n      pnt_location.x = floor(pnt_location.x / 2.);\n\n      //just an extra fragment -> return\n      if(pnt_location.y*points_per_row + pnt_location.x >= num_points) {\n        gl_FragColor = vec4(0,0,0,1);\n        return;\n      }\n\n      float width = (points_per_row * 2.0);\n      float row_coord = (pnt_location.y + 0.5)/num_rows;\n      vec2 rad_coord = vec2((pnt_location.x * 2. + 0.5) / width, row_coord);\n      vec2 ang_coord = vec2((pnt_location.x * 2. + 1.5) / width, row_coord);\n\n      float rad = texture2D(random_tex,rad_coord).r * 3.;\n      float ang = texture2D(random_tex,ang_coord).r * 3.1415 * 2.;\n\n      gl_FragColor = vec4(rad,ang,0,1);\n\n      if(dimension < 0.5) {\n        gl_FragColor = vec4(cos(ang) * rad,0,0,0);\n      }else{\n        gl_FragColor = vec4(sin(ang) * rad,0,0,0);\n      }\n    }\n  ")}function S(t,e,i,r,o,a,s){var l=t.gl;null!=s?t.setOutputMatrixTexture(s,a,2*o):n.webgl.webgl_util.bindCanvasToFramebuffer(t.gl),t.setProgram(e);var u=n.webgl.webgl_util.getProgramUniformLocationOrThrow(l,e,"random_tex");t.setInputMatrixTexture(i,u,3);var g=n.webgl.webgl_util.getProgramUniformLocationOrThrow(l,e,"num_rows");l.uniform1f(g,a);var h=n.webgl.webgl_util.getProgramUniformLocationOrThrow(l,e,"num_points");l.uniform1f(h,r);var p=n.webgl.webgl_util.getProgramUniformLocationOrThrow(l,e,"points_per_row");l.uniform1f(p,o),t.executeProgram()}function j(t){return t.createProgram("\n    precision highp float;\n\n    #define MAX_NEIGHBORS 128\n    #define MAX_ITERATIONS 500\n    #define FLOAT_MAX 10e30\n    #define TOLERANCE 1e-5\n\n    uniform sampler2D knn_graph_tex;\n    uniform float points_per_row;\n    uniform float num_rows;\n    uniform float num_points;\n    uniform float num_neighs;\n    uniform float perplexity;\n\n    vec2 half_pixel = vec2(0.5,0.5);\n    float distances_squared[MAX_NEIGHBORS];\n\n    void readDistances(vec2 point_location) {\n      for(int n = 0; n < MAX_NEIGHBORS; ++n ) {\n        if(float(n) >= num_neighs-0.1) {\n          break;\n        }\n        vec2 knn_coordinates = vec2(\n            (point_location.x * num_neighs + float(n) + half_pixel.x)\n                                        /(points_per_row * num_neighs),\n            (point_location.y + half_pixel.y) / num_rows\n        );\n        distances_squared[n] = texture2D(knn_graph_tex,knn_coordinates).g;\n      }\n    }\n\n    void main() {\n      vec2 point_location = gl_FragCoord.xy - half_pixel;\n      //invalid points\n      if(point_location.y*points_per_row + point_location.x >= num_points) {\n        gl_FragColor = vec4(0,0,0,0);\n        return;\n      }\n      readDistances(point_location);\n\n      //Beta computation\n      float beta = 1.;\n      float max_beta = FLOAT_MAX;\n      float min_beta = -FLOAT_MAX;\n      //To avoid computing the log at every iteration\n      float log_perplexity = log(perplexity);\n      float entropy_diff = 0.;\n      float entropy = 0.;\n      float sum_probabilities = 0.;\n\n      //Binary search for a maximum of MAX_ITERATIONS\n      for(int iteration = 0; iteration < MAX_ITERATIONS; ++iteration) {\n        //At every iteration I compute the\n        //entropy enforced by the current beta\n        sum_probabilities = 0.;\n        entropy = 0.;\n        for(int n = 0; n < MAX_NEIGHBORS; ++n ) {\n          if(float(n) >= num_neighs-0.1) {\n            break;\n          }\n          float neigh_probability = exp(-beta * distances_squared[n]);\n          sum_probabilities += neigh_probability;\n          entropy += beta * distances_squared[n] * neigh_probability;\n        }\n\n        entropy = entropy / sum_probabilities + log(sum_probabilities);\n        entropy_diff = entropy - log_perplexity;\n\n        //the current beta is good enough!\n        if(entropy_diff < TOLERANCE && -entropy_diff < TOLERANCE) {\n          break;\n        }\n\n        if(entropy_diff > 0.) {\n          min_beta = beta;\n          if(max_beta == FLOAT_MAX || max_beta == -FLOAT_MAX) {\n            beta *= 2.;\n          }else{\n            beta = (beta + max_beta) / 2.;\n          }\n        }else{\n          max_beta = beta;\n          if(min_beta == -FLOAT_MAX || min_beta == FLOAT_MAX) {\n            beta /= 2.;\n          }else{\n            beta = (beta + min_beta) / 2.;\n          }\n        }\n      }\n      gl_FragColor = vec4(beta,sum_probabilities,0,1);\n    }\n  ")}function U(t,e,i,r,o,a,s,l,u){var g=t.gl;null!=u?t.setOutputMatrixTexture(u,s,a):n.webgl.webgl_util.bindCanvasToFramebuffer(t.gl),t.setProgram(e);var h=n.webgl.webgl_util.getProgramUniformLocationOrThrow(g,e,"knn_graph_tex");t.setInputMatrixTexture(i,h,0);var p=n.webgl.webgl_util.getProgramUniformLocationOrThrow(g,e,"num_rows");g.uniform1f(p,s);var m=n.webgl.webgl_util.getProgramUniformLocationOrThrow(g,e,"num_points");g.uniform1f(m,r);var _=n.webgl.webgl_util.getProgramUniformLocationOrThrow(g,e,"points_per_row");g.uniform1f(_,a);var f=n.webgl.webgl_util.getProgramUniformLocationOrThrow(g,e,"num_neighs");g.uniform1f(f,o);var d=n.webgl.webgl_util.getProgramUniformLocationOrThrow(g,e,"perplexity");g.uniform1f(d,l),t.executeProgram()}function C(t){return t.createProgram("\n    precision highp float;\n    uniform sampler2D knn_graph_tex;\n    uniform sampler2D parameters_tex;\n    uniform float points_per_row;\n    uniform float num_rows;\n    uniform float num_points;\n    uniform float num_neighs;\n\n    vec2 half_pixel = vec2(0.5,0.5);\n\n    void main() {\n      vec2 point_location = gl_FragCoord.xy - half_pixel;\n      point_location.x = floor(point_location.x / num_neighs);\n\n      //invalid points\n      if(point_location.y*points_per_row + point_location.x >= num_points) {\n        gl_FragColor = vec4(0,0,0,0);\n        return;\n      }\n      float distance_squared\n            = texture2D(knn_graph_tex,\n                        gl_FragCoord.xy /\n                        vec2(points_per_row*num_neighs,num_rows)\n                      ).g;\n      vec2 parameters\n            = texture2D(parameters_tex,\n                        (point_location.xy + half_pixel)/\n                        vec2(points_per_row,num_rows)\n                      ).rg;\n      float beta = parameters.r;\n      float normalization = parameters.g;\n\n      float probability = exp(-beta * distance_squared) / normalization;\n      //check for NaN for degenerated knn (d = 0 for every point)\n      if (!(probability < 0.0 || 0.0 < probability || probability == 0.0)) {\n        probability = 0.;\n      }\n\n      gl_FragColor = vec4(probability,0,0,1);\n    }\n  ")}function M(t,e,i,r,o,a,s,l,u){var g=t.gl;null!=u?t.setOutputMatrixTexture(u,l,s*a):n.webgl.webgl_util.bindCanvasToFramebuffer(t.gl),t.setProgram(e);var h=n.webgl.webgl_util.getProgramUniformLocationOrThrow(g,e,"knn_graph_tex");t.setInputMatrixTexture(i,h,0);var p=n.webgl.webgl_util.getProgramUniformLocationOrThrow(g,e,"parameters_tex");t.setInputMatrixTexture(r,p,1);var m=n.webgl.webgl_util.getProgramUniformLocationOrThrow(g,e,"num_rows");g.uniform1f(m,l);var _=n.webgl.webgl_util.getProgramUniformLocationOrThrow(g,e,"num_points");g.uniform1f(_,o);var f=n.webgl.webgl_util.getProgramUniformLocationOrThrow(g,e,"points_per_row");g.uniform1f(f,s);var d=n.webgl.webgl_util.getProgramUniformLocationOrThrow(g,e,"num_neighs");g.uniform1f(d,a),t.executeProgram()}function F(){var t=n.ENV.findBackend("webgl");if(null===t)throw Error("WebGL backend is not available");var e=t.getGPGPUContext().gl,i=4*(e.getParameter(e.MAX_VARYING_VECTORS)-1);return Math.floor(i/3)}var L="\n//Random function developed by Inigo Quilez\n//https://www.shadertoy.com/view/llGSzw\nfloat hash1( uint n ) {\n    // integer hash copied from Hugo Elias\n\t  n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\nfloat random( float f ) {\n    const uint mantissaMask = 0x007FFFFFu;\n    const uint one          = 0x3F800000u;\n\n    uint h = hash( floatBitsToUint( f ) );\n    h &= mantissaMask;\n    h |= one;\n\n    float  r2 = uintBitsToFloat( h );\n    return r2 - 1.0;\n}\n\n\n// #define HASHSCALE1 .1031\n// float random(float p) {\n// \tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n//   p3 += dot(p3, p3.yzx + 19.19);\n//   return fract((p3.x + p3.y) * p3.z);\n// }\n\n// const vec2 randomConst = vec2(\n//   23.14069263277926, // e^pi (Gelfond's constant)\n//    2.665144142690225 // 2^sqrt(2) (Gelfondâ€“Schneider constant)\n// );\n// float random(float seed) {\n//     return fract(cos(dot(vec2(seed,seed), randomConst)) * 12345.6789);\n// }\n\n",G="\n//Reads the distances and indices from the knn texture\nvoid initializeDistances(int pnt_id) {\n  //row coordinate in the texture\n  float row = (floor(float(pnt_id)/points_per_row_knn)+0.5)/num_rows_knn;\n  //column of the first neighbor\n  float start_col = mod(float(pnt_id),points_per_row_knn)*NUM_NEIGHBORS_FLOAT;\n  for(int n = 0; n < NUM_NEIGHBORS; n++) {\n    float col = (start_col+float(n)+0.5);\n    //normalized by the width of the texture\n    col /= (points_per_row_knn*NUM_NEIGHBORS_FLOAT);\n    //reads the index in the red channel and the distances in the green one\n    vec4 init = texture(starting_knn_tex,vec2(col,row));\n\n    knn_heap[n] = int(init.r);\n    distances_heap[n] = init.g;\n  }\n}\n",z="\n//Swaps two points in the knn-heap\nvoid swap(int i, int j) {\n  float swap_value = distances_heap[i];\n  distances_heap[i] = distances_heap[j];\n  distances_heap[j] = swap_value;\n  int swap_id = knn_heap[i];\n  knn_heap[i] = knn_heap[j];\n  knn_heap[j] = swap_id;\n}\n\n//I can make use of the heap property but\n//I have to implement a recursive function\nbool inTheHeap(float dist_sq, int id) {\n  for(int i = 0; i < NUM_NEIGHBORS; ++i) {\n    if(knn_heap[i] == id) {\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid insertInKNN(float dist_sq, int j) {\n  //not in the KNN\n  if(dist_sq >= distances_heap[0]) {\n    return;\n  }\n\n  //the point is already in the KNN\n  if(inTheHeap(dist_sq,j)) {\n    return;\n  }\n\n  //Insert in the new point in the root\n  distances_heap[0] = dist_sq;\n  knn_heap[0] = j;\n  //Sink procedure\n  int swap_id = 0;\n  while(swap_id*2+1 < NUM_NEIGHBORS) {\n    int left_id = swap_id*2+1;\n    int right_id = swap_id*2+2;\n    if(distances_heap[left_id] > distances_heap[swap_id] ||\n        (right_id < NUM_NEIGHBORS &&\n                            distances_heap[right_id] > distances_heap[swap_id])\n      ) {\n      if(distances_heap[left_id] > distances_heap[right_id]\n         || right_id >= NUM_NEIGHBORS) {\n        swap(swap_id,left_id);\n        swap_id = left_id;\n      }else{\n        swap(swap_id,right_id);\n        swap_id = right_id;\n      }\n    }else{\n      break;\n    }\n  }\n}\n",B="\n  //Line positions\n  float row = (floor(float(point_id)/points_per_row_knn)+0.5)/num_rows_knn;\n  row = row*2.0-1.0;\n  if(line_id < int(1)) {\n    //for the first vertex only the position is important\n    float col = (mod(float(point_id),points_per_row_knn))/(points_per_row_knn);\n    col = col*2.0-1.0;\n    gl_Position = vec4(col,row,0,1);\n    neighbor_id = 0.;\n    return;\n  }\n  //The computation of the KNN happens only for the second vertex\n  float col = (mod(float(point_id),points_per_row_knn)+1.)/(points_per_row_knn);\n  col = col*2.0-1.0;\n  gl_Position = vec4(col,row,0,1);\n",q=function(){function t(t,e,i,r,o,a){if(null!=a?this.verbose=a:a=!1,this.backend=n.ENV.findBackend("webgl"),this.gpgpu=this.backend.getGPGPUContext(),this._iteration=0,this.dataTexture=t,o>128)throw new Error("kNN size must not be greater than 128");if(o%4!=0)throw new Error("kNN size must be a multiple of 4");this.numNeighs=o;var s=Math.ceil(Math.sqrt(o*i)/o);this.knnDataShape={numPoints:i,pixelsPerPoint:o,pointsPerRow:s,numRows:Math.ceil(i/s)},this.log("knn-pntsPerRow",this.knnDataShape.pointsPerRow),this.log("knn-numRows",this.knnDataShape.numRows),this.log("knn-pixelsPerPoint",this.knnDataShape.pixelsPerPoint);var u;w(e)?u=l(e):x(e)&&(u=e.distanceComputationCode),this.initializeTextures(),this.initilizeCustomWebGLPrograms(u)}return Object.defineProperty(t.prototype,"knnShape",{get:function(){return this.knnDataShape},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"iteration",{get:function(){return this._iteration},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"pointsPerIteration",{get:function(){return 20},enumerable:!0,configurable:!0}),t.prototype.log=function(t,n){this.verbose&&(null!=n?console.log(t+": \t"+n):console.log(t))},t.prototype.initializeTextures=function(){for(var t=new Float32Array(this.knnDataShape.pointsPerRow*this.knnDataShape.pixelsPerPoint*2*this.knnDataShape.numRows),n=this.knnDataShape.pixelsPerPoint,e=0;e<this.knnDataShape.numPoints;++e)for(var i=0;i<n;++i)t[2*(e*n+i)]=-1,t[2*(e*n+i)+1]=1e31;this.knnTexture0=r(this.gpgpu.gl,this.knnDataShape.pointsPerRow*this.knnDataShape.pixelsPerPoint,this.knnDataShape.numRows,2,t),this.knnTexture1=r(this.gpgpu.gl,this.knnDataShape.pointsPerRow*this.knnDataShape.pixelsPerPoint,this.knnDataShape.numRows,2,t)},t.prototype.initilizeCustomWebGLPrograms=function(t){this.copyDistancesProgram=f(this.gpgpu),this.copyIndicesProgram=c(this.gpgpu),this.bruteForceKNNProgram=h(this.gpgpu,this.numNeighs,t),this.randomSamplingKNNProgram=p(this.gpgpu,this.numNeighs,t),this.kNNDescentProgram=m(this.gpgpu,this.numNeighs,t);for(var e=new Float32Array(2*this.knnDataShape.numPoints),i=0;i<2*this.knnDataShape.numPoints;++i)e[i]=i;this.linesVertexIdBuffer=n.webgl.webgl_util.createStaticVertexBuffer(this.gpgpu.gl,e)},t.prototype.iterateBruteForce=function(){this._iteration%2==0?this.iterateGPU(this.dataTexture,this._iteration,this.knnTexture0,this.knnTexture1):this.iterateGPU(this.dataTexture,this._iteration,this.knnTexture1,this.knnTexture0),++this._iteration,this.gpgpu.gl.finish()},t.prototype.iterateRandomSampling=function(){this._iteration%2==0?this.iterateRandomSamplingGPU(this.dataTexture,this._iteration,this.knnTexture0,this.knnTexture1):this.iterateRandomSamplingGPU(this.dataTexture,this._iteration,this.knnTexture1,this.knnTexture0),++this._iteration,this.gpgpu.gl.finish()},t.prototype.iterateKNNDescent=function(){this._iteration%2==0?this.iterateKNNDescentGPU(this.dataTexture,this._iteration,this.knnTexture0,this.knnTexture1):this.iterateKNNDescentGPU(this.dataTexture,this._iteration,this.knnTexture1,this.knnTexture0),++this._iteration,this.gpgpu.gl.finish()},t.prototype.knn=function(){return this._iteration%2==0?this.knnTexture0:this.knnTexture1},t.prototype.distancesTensor=function(){var t=this;return n.tidy(function(){var e=n.zeros([t.knnDataShape.numRows,t.knnDataShape.pointsPerRow*t.knnDataShape.pixelsPerPoint]),i=t.knn();return d(t.gpgpu,t.copyDistancesProgram,i,t.knnDataShape,t.backend.getTexture(e.dataId)),e.reshape([t.knnDataShape.numRows*t.knnDataShape.pointsPerRow,t.knnDataShape.pixelsPerPoint]).slice([0,0],[t.knnDataShape.numPoints,t.knnDataShape.pixelsPerPoint])})},t.prototype.indicesTensor=function(){var t=this;return n.tidy(function(){var e=n.zeros([t.knnDataShape.numRows,t.knnDataShape.pointsPerRow*t.knnDataShape.pixelsPerPoint]),i=t.knn();return b(t.gpgpu,t.copyIndicesProgram,i,t.knnDataShape,t.backend.getTexture(e.dataId)),e.reshape([t.knnDataShape.numRows*t.knnDataShape.pointsPerRow,t.knnDataShape.pixelsPerPoint]).slice([0,0],[t.knnDataShape.numPoints,t.knnDataShape.pixelsPerPoint])})},t.prototype.iterateGPU=function(t,n,e,i){_(this.gpgpu,this.bruteForceKNNProgram,t,e,n,this.knnDataShape,this.linesVertexIdBuffer,i)},t.prototype.iterateRandomSamplingGPU=function(t,n,e,i){_(this.gpgpu,this.randomSamplingKNNProgram,t,e,n,this.knnDataShape,this.linesVertexIdBuffer,i)},t.prototype.iterateKNNDescentGPU=function(t,n,e,i){_(this.gpgpu,this.kNNDescentProgram,t,e,n,this.knnDataShape,this.linesVertexIdBuffer,i)},t}(),X=function(){function t(t,e,i,r){if(null!=e?this.verbose=e:e=!1,this.log("Initializing the tSNE gradient descent computation..."),this.numPoints=t,this._iteration=0,1===n.ENV.get("WEBGL_VERSION"))throw Error("WebGL version 1 is not supported by tfjs-tsne");if(this.backend=n.ENV.findBackend("webgl"),null===this.backend)throw Error("WebGL backend is not available");this.gpgpu=this.backend.getGPGPUContext(),n.webgl.webgl_util.getExtensionOrThrow(this.gpgpu.gl,"OES_texture_float_linear"),this.pointsPerRow=Math.ceil(Math.sqrt(2*t)),this.pointsPerRow%2==1&&++this.pointsPerRow,this.pointsPerRow/=2,this.numRows=Math.ceil(t/this.pointsPerRow),this.log("\t# points per row",this.pointsPerRow),this.log("\t# rows",this.numRows),this._eta=2500,this._momentum=n.scalar(.8),this.rawExaggeration=[{iteration:200,value:4},{iteration:600,value:1}],this.updateExaggeration(),null==i&&(i=5),this.splatTextureDiameter=i,null==r&&(r=50),this.kernelTextureDiameter=2*r+1,this.initializeRepulsiveForceTextures(),this.log("\tSplat texture diameter",this.splatTextureDiameter),this.log("\tKernel texture diameter",this.kernelTextureDiameter),this.initilizeCustomWebGLPrograms(),this.initializeEmbedding(),this.log("\tEmbedding",this.embedding),this.log("\tGradient",this.gradient)}return Object.defineProperty(t.prototype,"minX",{get:function(){return this._minX},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"maxX",{get:function(){return this._maxX},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"minY",{get:function(){return this._minY},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"maxY",{get:function(){return this._maxY},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"iteration",{get:function(){return this._iteration},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"numberOfPoints",{get:function(){return this.numPoints},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"numberOfPointsPerRow",{get:function(){return this.pointsPerRow},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"numberOfRows",{get:function(){return this.numRows},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"embeddingCoordinates",{get:function(){return this.embedding},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"embedding2D",{get:function(){var t=this;return n.tidy(function(){return t.embedding.reshape([t.numRows*t.pointsPerRow,2]).slice([0,0],[t.numPoints,2])})},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"embeddingTexture",{get:function(){return this.backend.getTexture(this.embedding.dataId)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"splatTexture",{get:function(){return this._splatTexture},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"normalizationQ",{get:function(){return this._normQ},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"exaggerationAtCurrentIteration",{get:function(){return this._exaggeration.get()},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"exaggeration",{get:function(){return this.rawExaggeration},set:function(t){if(this.rawExaggeration=t,"number"==typeof t){if(t<1)throw Error("Exaggeration must be greater then or equal to one")}else{for(n=0;n<t.length;++n){if(t[n].value<1)throw Error("Exaggeration must be greater then or equal to one");if(t[n].iteration<0)throw Error("Piecewise linear exaggeration function                                         must have poistive iteration values")}for(var n=0;n<t.length-1;++n)if(t[n].iteration>=t[n+1].iteration)throw Error("Piecewise linear exaggeration function                                       must have increasing iteration values");1===t.length&&(this.exaggeration=t[0].value)}this.updateExaggeration()},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"momentum",{get:function(){return this._momentum.get()},set:function(t){if(t<0||t>1)throw Error("Momentum must be in the [0,1] range");this._momentum.dispose(),this._momentum=n.scalar(t)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"eta",{get:function(){return this._eta},set:function(t){if(t<=0)throw Error("ETA must be greater then zero");this._eta=t},enumerable:!0,configurable:!0}),t.prototype.dispose=function(){this.embedding.dispose(),this.gradient.dispose(),this._momentum.dispose(),this._exaggeration.dispose(),this.gpgpu.gl.deleteTexture(this._splatTexture),this.gpgpu.gl.deleteTexture(this.kernelTexture),null!=this.kernelTexture&&this.gpgpu.gl.deleteTexture(this.probOffsetTexture),null!=this.kernelTexture&&this.gpgpu.gl.deleteTexture(this.probNeighIdTexture),null!=this.kernelTexture&&this.gpgpu.gl.deleteTexture(this.probTexture),this.gpgpu.gl.deleteBuffer(this.splatVertexIdBuffer),this.gpgpu.gl.deleteProgram(this.embeddingInitializationProgram),this.gpgpu.gl.deleteProgram(this.embeddingSplatterProgram),this.gpgpu.gl.deleteProgram(this.qInterpolatorProgram),this.gpgpu.gl.deleteProgram(this.xyInterpolatorProgram),this.gpgpu.gl.deleteProgram(this.attractiveForcesProgram),this.gpgpu.gl.deleteProgram(this.distributionParameterssComputationProgram),this.gpgpu.gl.deleteProgram(this.gaussiaDistributionsFromDistancesProgram)},t.prototype.initializeEmbedding=function(){var t=this;null!=this.embedding&&this.embedding.dispose(),null!=this.gradient&&this.gradient.dispose(),this.gradient=n.zeros([this.numRows,2*this.pointsPerRow]),this.embedding=n.tidy(function(){var e=n.randomUniform([t.numRows,2*t.pointsPerRow]),i=n.zeros([t.numRows,2*t.pointsPerRow]);return t.initializeEmbeddingPositions(i,e),i});this._minX=-3,this._minY=-3,this._maxX=3,this._maxY=3,this.log("\tmin X",this._minX),this.log("\tmax X",this._maxX),this.log("\tmin Y",this._minY),this.log("\tmax Y",this._maxY),this._iteration=0},t.prototype.initializeNeighbors=function(t,n,e,i){this.numNeighPerRow=t,this.probOffsetTexture=n,this.probTexture=e,this.probNeighIdTexture=i},t.prototype.initializeNeighborsFromKNNGraph=function(t,n,e,i){return v(this,void 0,void 0,function(){var o,a,s,l,u,g,h,p;return P(this,function(m){switch(m.label){case 0:for(o=Math.floor(Math.sqrt(t*n)/n),a=Math.ceil(t/o),s={numPoints:t,pixelsPerPoint:n,numRows:a,pointsPerRow:o},l=new Float32Array(o*n*a*2),u=0;u<t;++u)for(g=0;g<n;++g)l[2*(h=u*n+g)]=i[h],l[2*h+1]=e[h];return p=r(this.gpgpu.gl,o*n,a,2,l),[4,this.initializeNeighborsFromKNNTexture(s,p)];case 1:return m.sent(),this.gpgpu.gl.deleteTexture(p),[2]}})})},t.prototype.initializeNeighborsFromKNNTexture=function(t,e){return v(this,void 0,void 0,function(){var i,o,a,s,l,u,g,h,p,m,_,f,d,w,x,v,T,k,N,y,R,E,D,O,I,A,S;return P(this,function(P){switch(P.label){case 0:if(this.log("Asymmetric neighborhood initialization..."),t.numPoints!==this.numPoints)throw new Error("KNN size and number of points must agree("+t.numPoints+","+this.numPoints+")");return i=r(this.gpgpu.gl,t.pointsPerRow,t.numRows,2),o=n.zeros([t.numRows,t.pointsPerRow*t.pixelsPerPoint]),a=t.pixelsPerPoint/3,this.computeDistributionParameters(i,t,a,e),this.computeGaussianDistributions(o,i,t,e),[4,o.data()];case 1:return s=P.sent(),this.log("Gaussian distributions",o),l=n.zeros([t.numRows,t.pointsPerRow*t.pixelsPerPoint]),u=c(this.gpgpu),b(this.gpgpu,u,e,t,this.backend.getTexture(l.dataId)),[4,l.data()];case 2:for(g=P.sent(),this.log("knn Indices",l),h=new Float32Array(t.numPoints*t.pixelsPerPoint),R=0;R<this.numPoints;++R)for(p=0;p<t.pixelsPerPoint;++p)D=R*t.pixelsPerPoint+p,h[R*t.pixelsPerPoint+p]=g[D];for(this.log("NeighIds",h),m=new Uint32Array(this.numPoints),_=new Uint32Array(this.numPoints),R=0;R<t.numPoints*t.pixelsPerPoint;++R)++m[h[R]];for(R=1;R<t.numPoints;++R)_[R]=_[R-1]+m[R-1]+t.pixelsPerPoint;for(this.log("Counter",m),this.log("Linear offset",_),f=0,d=0,w=0,R=0;R<m.length;++R)f+=m[R],m[R]>d&&(d=m[R],w=R);for(this.log("Number of indirect links",f),this.log("Most central point",w),this.log("Number of indirect links for the central point",d),this.numNeighPerRow=Math.ceil(Math.sqrt(t.numPoints*t.pixelsPerPoint*2)),this.log("numNeighPerRow",this.numNeighPerRow),x=new Float32Array(this.pointsPerRow*this.numRows*3),v=0,R=0;R<this.numPoints;++R)T=t.pixelsPerPoint+m[R],x[3*R+0]=v%this.numNeighPerRow,x[3*R+1]=Math.floor(v/this.numNeighPerRow),x[3*R+2]=T,v+=T;for(this.log("Offsets",x),this.probOffsetTexture=r(this.gpgpu.gl,this.pointsPerRow,this.numRows,3,x),k=new Float32Array(this.numNeighPerRow*this.numNeighPerRow),N=new Float32Array(this.numNeighPerRow*this.numNeighPerRow),y=new Uint32Array(this.numPoints),R=0;R<this.numPoints;++R)for(E=0;E<t.pixelsPerPoint;++E)D=R*t.pixelsPerPoint+E,O=g[D],I=s[D],A=_[R]+E,S=_[O]+t.pixelsPerPoint+y[O],k[A]=I,k[S]=I,N[A]=O,N[S]=R,++y[O];return this.log("Probabilities",k),this.log("Neighbors",N),this.probTexture=r(this.gpgpu.gl,this.numNeighPerRow,this.numNeighPerRow,1,k),this.probNeighIdTexture=r(this.gpgpu.gl,this.numNeighPerRow,this.numNeighPerRow,1,N),o.dispose(),l.dispose(),this.log("...done!"),[2]}})})},t.prototype.initializedNeighborhoods=function(){return null!=this.probNeighIdTexture},t.prototype.updateExaggeration=function(){if(void 0!==this._exaggeration&&this._exaggeration.dispose(),"number"!=typeof this.rawExaggeration)if(this._iteration<=this.rawExaggeration[0].iteration)this._exaggeration=n.scalar(this.rawExaggeration[0].value);else if(this._iteration>=this.rawExaggeration[this.rawExaggeration.length-1].iteration)this._exaggeration=n.scalar(this.rawExaggeration[this.rawExaggeration.length-1].value);else{for(var t=0;t<this.rawExaggeration.length&&this._iteration<this.rawExaggeration[t].iteration;)++t;var e=this.rawExaggeration[t].iteration,i=this.rawExaggeration[t+1].iteration,r=this.rawExaggeration[t].value,o=this.rawExaggeration[t+1].value,a=(i-this._iteration)/(i-e),s=r*a+o*(1-a);this._exaggeration=n.scalar(s)}else this._exaggeration=n.scalar(this.rawExaggeration)},t.prototype.iterate=function(){return v(this,void 0,void 0,function(){var t,e,i,r=this;return P(this,function(o){switch(o.label){case 0:if(!this.initializedNeighborhoods())throw new Error("No neighborhoods defined. You may want to call                    initializeNeighbors or initializeNeighborsFromKNNGraph");return this.updateSplatTextureDiameter(),this.updateExaggeration(),i=n.tidy(function(){r.splatPoints();var t=n.zeros([r.numRows,r.pointsPerRow]),e=n.zeros([r.numRows,2*r.pointsPerRow]);r.computeInterpolatedQ(t),r.computeInterpolatedXY(e);var i=t.sum(),o=e.div(i),a=n.zeros([r.numRows,2*r.pointsPerRow]);r.computeAttractiveForces(a);var s=a.mul(r._exaggeration).sub(o),l=r.gradient.mul(r._momentum).sub(s);return r.gradient.dispose(),[l,i]}),this.gradient=i[0],t=i[1],e=this,[4,t.data()];case 1:return e._normQ=o.sent()[0],t.dispose(),this.embedding=n.tidy(function(){var t=r.embedding.add(r.gradient);return r.embedding.dispose(),t}),[4,this.computeBoundaries()];case 2:return o.sent(),++this._iteration,[2]}})})},t.prototype.log=function(t,n){this.verbose&&(null!=n?console.log(t+": \t"+n):console.log(t))},t.prototype.initializeRepulsiveForceTextures=function(){this._splatTexture=i(this.gpgpu.gl,this.splatTextureDiameter,this.splatTextureDiameter,4,null),this.kernelSupport=2.5;var t=new Float32Array(this.kernelTextureDiameter*this.kernelTextureDiameter*4),n=Math.floor(this.kernelTextureDiameter/2),e=0,r=0;for(e=0;e<this.kernelTextureDiameter;++e)for(r=0;r<this.kernelTextureDiameter;++r){var o=(r-n)/n*this.kernelSupport,a=(e-n)/n*this.kernelSupport,s=1/(1+(o*o+a*a)),l=4*(e*this.kernelTextureDiameter+r);t[l+0]=s,t[l+1]=s*s*o,t[l+2]=s*s*a,t[l+3]=1}this.kernelTexture=i(this.gpgpu.gl,this.kernelTextureDiameter,this.kernelTextureDiameter,4,t)},t.prototype.initilizeCustomWebGLPrograms=function(){this.log("\tCreating custom programs..."),this.embeddingInitializationProgram=A(this.gpgpu),this.embeddingSplatterProgram=k(this.gpgpu);var t=new Float32Array(6*this.numPoints),e=0,i=0;for(e=0;e<this.numPoints;++e)t[(i=6*e)+0]=0+4*e,t[i+1]=1+4*e,t[i+2]=2+4*e,t[i+3]=0+4*e,t[i+4]=2+4*e,t[i+5]=3+4*e;this.splatVertexIdBuffer=n.webgl.webgl_util.createStaticVertexBuffer(this.gpgpu.gl,t),this.qInterpolatorProgram=y(this.gpgpu),this.xyInterpolatorProgram=E(this.gpgpu),this.attractiveForcesProgram=O(this.gpgpu),this.distributionParameterssComputationProgram=j(this.gpgpu),this.gaussiaDistributionsFromDistancesProgram=C(this.gpgpu)},t.prototype.computeBoundaries=function(){return v(this,void 0,void 0,function(){var t,e,i,r,o,a,s,l,u=this;return P(this,function(g){switch(g.label){case 0:return t=n.tidy(function(){var t=u.embedding.reshape([u.numRows*u.pointsPerRow,2]).slice([0,0],[u.numPoints,2]);return[t.min(0),t.max(0)]}),e=t[0],i=t[1],[4,e.data()];case 1:return r=g.sent(),[4,i.data()];case 2:return o=g.sent(),a=.05,s=(o[0]-r[0])*a,this._minX=r[0]-s,this._maxX=o[0]+s,l=(o[1]-r[1])*a,this._minY=r[1]-l,this._maxY=o[1]+l,e.dispose(),i.dispose(),[2]}})})},t.prototype.updateSplatTextureDiameter=function(){var t=Math.max(this._maxX-this._minX,this._maxY-this._minY),n=Math.min(Math.ceil(Math.max(t/.35,5)),5e3);Math.abs(this.splatTextureDiameter-n)/this.splatTextureDiameter>=.2&&(this.log("Updating splat-texture diameter",n),this.gpgpu.gl.deleteTexture(this._splatTexture),this.splatTextureDiameter=n,this._splatTexture=i(this.gpgpu.gl,this.splatTextureDiameter,this.splatTextureDiameter,4,null))},t.prototype.initializeEmbeddingPositions=function(t,n){S(this.gpgpu,this.embeddingInitializationProgram,this.backend.getTexture(n.dataId),this.numPoints,this.pointsPerRow,this.numRows,this.backend.getTexture(t.dataId))},t.prototype.splatPoints=function(){N(this.gpgpu,this.embeddingSplatterProgram,this._splatTexture,this.backend.getTexture(this.embedding.dataId),this.kernelTexture,this.splatTextureDiameter,this.numPoints,this._minX,this._minY,this._maxX,this._maxY,this.kernelSupport,this.pointsPerRow,this.numRows,this.splatVertexIdBuffer)},t.prototype.computeInterpolatedQ=function(t){R(this.gpgpu,this.qInterpolatorProgram,this._splatTexture,this.backend.getTexture(this.embedding.dataId),this.numPoints,this._minX,this._minY,this._maxX,this._maxY,this.pointsPerRow,this.numRows,this.backend.getTexture(t.dataId))},t.prototype.computeInterpolatedXY=function(t){D(this.gpgpu,this.xyInterpolatorProgram,this._splatTexture,this.backend.getTexture(this.embedding.dataId),this.backend.getTexture(t.dataId),this.numPoints,this._minX,this._minY,this._maxX,this._maxY,this.pointsPerRow,this.numRows,this._eta)},t.prototype.computeAttractiveForces=function(t){I(this.gpgpu,this.attractiveForcesProgram,this.backend.getTexture(this.embedding.dataId),this.probOffsetTexture,this.probNeighIdTexture,this.probTexture,this.numPoints,this.numNeighPerRow,this.pointsPerRow,this.numRows,this._eta,this.backend.getTexture(t.dataId))},t.prototype.computeDistributionParameters=function(t,n,e,i){U(this.gpgpu,this.distributionParameterssComputationProgram,i,n.numPoints,n.pixelsPerPoint,n.pointsPerRow,n.numRows,e,t)},t.prototype.computeGaussianDistributions=function(t,n,e,i){M(this.gpgpu,this.gaussiaDistributionsFromDistancesProgram,i,n,e.numPoints,e.pixelsPerPoint,e.pointsPerRow,e.numRows,this.backend.getTexture(t.dataId))},t}(),K=function(){function t(t,n){this.initialized=!1,this.probabilitiesInitialized=!1,this.data=t,this.config=n;var e=this.data.shape;if(this.numPoints=e[0],this.numDimensions=e[1],2!==e.length)throw Error("computeTSNE: input tensor must be 2-dimensional");var i=18;void 0!==this.config&&void 0!==this.config.perplexity&&(i=this.config.perplexity);var r=F();if(i>r)throw Error("computeTSNE: perplexity cannot be greater than"+r+" on this machine")}return t.prototype.initialize=function(){return v(this,void 0,void 0,function(){var t,n,e,i,r,o,a,s,l,u;return P(this,function(g){switch(g.label){case 0:return t=18,n=4,e=300,i=200,r=.8,this.verbose=!1,this.knnMode="auto",void 0!==this.config&&(void 0!==this.config.perplexity&&(t=this.config.perplexity),void 0!==this.config.exaggeration&&(n=this.config.exaggeration),void 0!==this.config.exaggerationIter&&(e=this.config.exaggerationIter),void 0!==this.config.exaggerationDecayIter&&(i=this.config.exaggerationDecayIter),void 0!==this.config.momentum&&(r=this.config.momentum),void 0!==this.config.verbose&&(this.verbose=this.config.verbose),void 0!==this.config.knnMode&&(this.knnMode=this.config.knnMode)),this.numNeighbors=4*Math.floor(3*t/4),o=this,[4,T(this.data)];case 1:return o.packedData=g.sent(),this.verbose&&(console.log("Number of points:\t"+this.numPoints),console.log("Number of dimensions:\t "+this.numDimensions),console.log("Number of neighbors:\t"+this.numNeighbors),console.log("kNN mode:\t"+this.knnMode)),this.knnEstimator=new q(this.packedData.texture,this.packedData.shape,this.numPoints,this.numDimensions,this.numNeighbors,!1),this.optimizer=new X(this.numPoints,!1),a=[{iteration:e,value:n},{iteration:e+i,value:1}],this.verbose&&console.log("Exaggerating for "+a[0].iteration+" iterations with a value of "+a[0].value+". Exaggeration is removed after "+a[1].iteration+"."),this.optimizer.exaggeration=a,this.optimizer.momentum=r,s=2500,l=250,u=2e3,this.numPoints>u?this.optimizer.eta=s:this.optimizer.eta=l+(s-l)*(this.numPoints/u),[2]}})})},t.prototype.compute=function(t){return void 0===t&&(t=1e3),v(this,void 0,void 0,function(){var n;return P(this,function(e){switch(e.label){case 0:return n=this.knnIterations(),this.verbose&&(console.log("Number of KNN iterations:\t"+n),console.log("Computing the KNN...")),[4,this.iterateKnn(n)];case 1:return e.sent(),this.verbose&&console.log("Computing the tSNE embedding..."),[4,this.iterate(t)];case 2:return e.sent(),this.verbose&&console.log("Done!"),[2]}})})},t.prototype.iterateKnn=function(t){return void 0===t&&(t=1),v(this,void 0,void 0,function(){var n;return P(this,function(e){switch(e.label){case 0:return this.initialized?[3,2]:[4,this.initialize()];case 1:e.sent(),e.label=2;case 2:for(this.probabilitiesInitialized=!1,n=0;n<t;++n)this.knnEstimator.iterateBruteForce(),this.knnEstimator.iteration%100==0&&this.verbose&&console.log("Iteration KNN:\t"+this.knnEstimator.iteration);return[2]}})})},t.prototype.iterate=function(t){return void 0===t&&(t=1),v(this,void 0,void 0,function(){var n;return P(this,function(e){switch(e.label){case 0:return this.probabilitiesInitialized?[3,2]:[4,this.initializeProbabilities()];case 1:e.sent(),e.label=2;case 2:n=0,e.label=3;case 3:return n<t?[4,this.optimizer.iterate()]:[3,6];case 4:e.sent(),this.optimizer.iteration%100==0&&this.verbose&&console.log("Iteration tSNE:\t"+this.optimizer.iteration),e.label=5;case 5:return++n,[3,3];case 6:return[2]}})})},t.prototype.knnIterations=function(){return Math.ceil(this.numPoints/20)},t.prototype.coordinates=function(t){var e=this;return void 0===t&&(t=!0),t?n.tidy(function(){var t=e.optimizer.maxX-e.optimizer.minX,i=e.optimizer.maxY-e.optimizer.minY,r=n.tensor2d([e.optimizer.minX,e.optimizer.minY],[1,2]),o=n.tensor2d([e.optimizer.maxX,e.optimizer.maxY],[1,2]).sub(r),a=n.max(o),s=n.tidy(function(){return t<i?n.tensor2d([(i-t)/2,0],[1,2]):n.tensor2d([0,(t-i)/2],[1,2])});return e.optimizer.embedding2D.sub(r).add(s).div(a)}):this.optimizer.embedding2D},t.prototype.coordsArray=function(t){return void 0===t&&(t=!0),v(this,void 0,void 0,function(){var n,e,i;return P(this,function(r){switch(r.label){case 0:return[4,this.coordinates(t).data()];case 1:for(n=r.sent(),e=[],i=0;i<n.length;i+=2)e.push([n[i],n[i+1]]);return[2,e]}})})},t.prototype.knnTotalDistance=function(){return v(this,void 0,void 0,function(){var t,e=this;return P(this,function(i){switch(i.label){case 0:return t=n.tidy(function(){return e.knnEstimator.distancesTensor().sum()}),[4,t.data()];case 1:return[2,i.sent()[0]]}})})},t.prototype.initializeProbabilities=function(){return v(this,void 0,void 0,function(){return P(this,function(t){switch(t.label){case 0:return this.verbose&&console.log("Initializing probabilities"),[4,this.optimizer.initializeNeighborsFromKNNTexture(this.knnEstimator.knnShape,this.knnEstimator.knn())];case 1:return t.sent(),this.probabilitiesInitialized=!0,[2]}})})},t}();t.KNNEstimator=q,t.maximumPerplexity=F,t.tsne=function(t,n){return new K(t,n)},t.TSNEOptimizer=X,Object.defineProperty(t,"__esModule",{value:!0})});